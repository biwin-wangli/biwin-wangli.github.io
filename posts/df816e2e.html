
<!DOCTYPE html>
<html lang="zh-cn">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="BiWin&#39;s Blog">
    <title>Java8新特性之流式数据处理 - BiWin&#39;s Blog</title>
    <meta name="author" content="Mr.WangLi">
    
        <meta name="keywords" content="Hexo,javascript,java,docker,kubernetes,jvm,mysql,nodejs,vue,mybatis,Java,JDK8,Basic">
    
    
    
    <script type="application/ld+json">{"@context":"http://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mr.WangLi","sameAs":["https://github.com/biwin-wangli","http://stackoverflow.com/users","https://www.linkedin.com/profile/","mailto:274027703@qq.com"],"image":"https://img.biwin.eu.org/touxiang.jpeg"},"articleBody":"\n\n\n一. 流式处理简介在我接触到java8流式处理的时候，我的第一感觉是流式处理让集合操作变得简洁了许多，通常我们需要多行代码才能完成的操作，借助于流式处理可以在一行中实现。比如我们希望对一个包含整数的集合中筛选出所有的偶数，并将其封装成为一个新的List返回，那么在java8之前，我们需要通过如下代码实现：\n123456List&lt;Integer&gt; evens = new ArrayList&lt;&gt;();for (final Integer num : nums) &#123;    if (num % 2 == 0) &#123;        evens.add(num);    &#125;&#125;\n\n通过java8的流式处理，我们可以将代码简化为：\n1List&lt;Integer&gt; evens = nums.stream().filter(num -&gt; num % 2 == 0).collect(Collectors.toList());\n\n先简单解释一下上面这行语句的含义，stream()操作将集合转换成一个流，filter()执行我们自定义的筛选处理，这里是通过lambda表达式筛选出所有偶数，最后我们通过collect()对结果进行封装处理，并通过Collectors.toList()指定其封装成为一个List集合返回。\n由上面的例子可以看出，java8的流式处理极大的简化了对于集合的操作，实际上不光是集合，包括数组、文件等，只要是可以转换成流，我们都可以借助流式处理，类似于我们写SQL语句一样对其进行操作。java8通过内部迭代来实现对流的处理，一个流式处理可以分为三个部分：转换成流、中间操作、终端操作。如下图：以集合为例，一个流式处理的操作我们首先需要调用stream()函数将其转换成流，然后再调用相应的中间操作达到我们需要对集合进行的操作，比如筛选、转换等，最后通过终端操作对前面的结果进行封装，返回我们需要的形式。\n二. 中间操作我们定义一个简单的学生实体类，用于后面的例子演示：\n1234567891011121314151617181920public class Student &#123;    /** 学号 */    private long id;    private String name;    private int age;    /** 年级 */    private int grade;    /** 专业 */    private String major;    /** 学校 */    private String school;    // 省略getter和setter&#125;\n\n123456789101112131415// 初始化List&lt;Student&gt; students = new ArrayList&lt;Student&gt;() &#123;    &#123;        add(new Student(20160001, &quot;孔明&quot;, 20, 1, &quot;土木工程&quot;, &quot;武汉大学&quot;));        add(new Student(20160002, &quot;伯约&quot;, 21, 2, &quot;信息安全&quot;, &quot;武汉大学&quot;));        add(new Student(20160003, &quot;玄德&quot;, 22, 3, &quot;经济管理&quot;, &quot;武汉大学&quot;));        add(new Student(20160004, &quot;云长&quot;, 21, 2, &quot;信息安全&quot;, &quot;武汉大学&quot;));        add(new Student(20161001, &quot;翼德&quot;, 21, 2, &quot;机械与自动化&quot;, &quot;华中科技大学&quot;));        add(new Student(20161002, &quot;元直&quot;, 23, 4, &quot;土木工程&quot;, &quot;华中科技大学&quot;));        add(new Student(20161003, &quot;奉孝&quot;, 23, 4, &quot;计算机科学&quot;, &quot;华中科技大学&quot;));        add(new Student(20162001, &quot;仲谋&quot;, 22, 3, &quot;土木工程&quot;, &quot;浙江大学&quot;));        add(new Student(20162002, &quot;鲁肃&quot;, 23, 4, &quot;计算机科学&quot;, &quot;浙江大学&quot;));        add(new Student(20163001, &quot;丁奉&quot;, 24, 5, &quot;土木工程&quot;, &quot;南京大学&quot;));    &#125;&#125;;\n\n2.1 过滤过滤，顾名思义就是按照给定的要求对集合进行筛选满足条件的元素，java8提供的筛选操作包括：filter、distinct、limit、skip。\nfilter在前面的例子中我们已经演示了如何使用filter，其定义为：Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)，filter接受一个谓词Predicate，我们可以通过这个谓词定义筛选条件，在介绍lambda表达式时我们介绍过Predicate是一个函数式接口，其包含一个test(T t)方法，该方法返回boolean。现在我们希望从集合students中筛选出所有武汉大学的学生，那么我们可以通过filter来实现，并将筛选操作作为参数传递给filter：\n123List&lt;Student&gt; whuStudents = students.stream()                                    .filter(student -&gt; &quot;武汉大学&quot;.equals(student.getSchool()))                                    .collect(Collectors.toList());\n\ndistinctdistinct操作类似于我们在写SQL语句时，添加的DISTINCT关键字，用于去重处理，distinct基于Object.equals(Object)实现，回到最开始的例子，假设我们希望筛选出所有不重复的偶数，那么可以添加distinct操作：\n123List&lt;Integer&gt; evens = nums.stream()                        .filter(num -&gt; num % 2 == 0).distinct()                        .collect(Collectors.toList());\n\nlimitlimit操作也类似于SQL语句中的LIMIT关键字，不过相对功能较弱，limit返回包含前n个元素的流，当集合大小小于n时，则返回实际长度，比如下面的例子返回前两个专业为土木工程专业的学生：\n123List&lt;Student&gt; civilStudents = students.stream()                                    .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())).limit(2)                                    .collect(Collectors.toList());\n\n说到limit，不得不提及一下另外一个流操作：sorted。该操作用于对流中元素进行排序，sorted要求待比较的元素必须实现Comparable接口，如果没有实现也不要紧，我们可以将比较器作为参数传递给sorted(Comparator&lt;? super T&gt; comparator)，比如我们希望筛选出专业为土木工程的学生，并按年龄从小到大排序，筛选出年龄最小的两个学生，那么可以实现为：\n1234List&lt;Student&gt; sortedCivilStudents = students.stream()                                            .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())).sorted((s1, s2) -&gt; s1.getAge() - s2.getAge())                                            .limit(2)                                            .collect(Collectors.toList());\n\nskipskip操作与limit操作相反，如同其字面意思一样，是跳过前n个元素，比如我们希望找出排序在2之后的土木工程专业的学生，那么可以实现为：\n1234List&lt;Student&gt; civilStudents = students.stream()                                    .filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor()))                                    .skip(2)                                    .collect(Collectors.toList());\n\n通过skip，就会跳过前面两个元素，返回由后面所有元素构造的流，如果n大于满足条件的集合的长度，则会返回一个空的集合。\n2.2 映射在SQL中，借助SELECT关键字后面添加需要的字段名称，可以仅输出我们需要的字段数据，而流式处理的映射操作也是实现这一目的，在java8的流式处理中，主要包含两类映射操作：map和flatMap。\nmap举例说明，假设我们希望筛选出所有专业为计算机科学的学生姓名，那么我们可以在filter筛选的基础之上，通过map将学生实体映射成为学生姓名字符串，具体实现如下：\n123List&lt;String&gt; names = students.stream()                            .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                            .map(Student::getName).collect(Collectors.toList());\n\n除了上面这类基础的map，java8还提供了mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)，mapToInt(ToIntFunction&lt;? super T&gt; mapper)，mapToLong(ToLongFunction&lt;? super T&gt; mapper)，这些映射分别返回对应类型的流，java8为这些流设定了一些特殊的操作，比如我们希望计算所有专业为计算机科学学生的年龄之和，那么我们可以实现如下：\n123int totalAge = students.stream()                    .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                    .mapToInt(Student::getAge).sum();\n\n通过将Student按照年龄直接映射为IntStream，我们可以直接调用提供的sum()方法来达到目的，此外使用这些数值流的好处还在于可以避免jvm装箱操作所带来的性能消耗。\nflatMapflatMap与map的区别在于flatMap是将一个流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流。举例说明，假设我们有一个字符串数组String[] strs = &#123;&quot;java8&quot;, &quot;is&quot;, &quot;easy&quot;, &quot;to&quot;, &quot;use&quot;&#125;;，我们希望输出构成这一数组的所有非重复字符，那么我们可能首先会想到如下实现：\n1234List&lt;String[]&gt; distinctStrs = Arrays.stream(strs)                                .map(str -&gt; str.split(&quot;&quot;))  // 映射成为Stream&lt;String[]&gt;                                .distinct()                                .collect(Collectors.toList());\n\n在执行map操作以后，我们得到是一个包含多个字符串（构成一个字符串的字符数组）的流，此时执行distinct操作是基于在这些字符串数组之间的对比，所以达不到我们希望的目的，此时的输出为：\n12345[j, a, v, a, 8][i, s][e, a, s, y][t, o][u, s, e]\n\ndistinct只有对于一个包含多个字符的流进行操作才能达到我们的目的，即对Stream&lt;String&gt;进行操作。此时flatMap就可以达到我们的目的：\n12345List&lt;String&gt; distinctStrs = Arrays.stream(strs)                                .map(str -&gt; str.split(&quot;&quot;))  // 映射成为Stream&lt;String[]&gt;                                .flatMap(Arrays::stream)  // 扁平化为Stream&lt;String&gt;                                .distinct()                                .collect(Collectors.toList());\n\nflatMap将由map映射得到的Stream&lt;String[]&gt;，转换成由各个字符串数组映射成的流Stream，再将这些小的流扁平化成为一个由所有字符串构成的大流Steam，从而能够达到我们的目的。与map类似，flatMap也提供了针对特定类型的映射操作：flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)，flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)，flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)。\n三. 终端操作终端操作是流式处理的最后一步，我们可以在终端操作中实现对流查找、归约等操作。\n3.1 查找allMatchallMatch用于检测是否全部都满足指定的参数行为，如果全部满足则返回true，例如我们希望检测是否所有的学生都已满18周岁，那么可以实现为：\n1boolean isAdult = students.stream().allMatch(student -&gt; student.getAge() &gt;= 18);\n\nanyMatchanyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true，例如我们希望检测是否有来自武汉大学的学生，那么可以实现为：\n1boolean hasWhu = students.stream().anyMatch(student -&gt; &quot;武汉大学&quot;.equals(student.getSchool()));\n\nnoneMathchnoneMatch用于检测是否不存在满足指定行为的元素，如果不存在则返回true，例如我们希望检测是否不存在专业为计算机科学的学生，可以实现如下：\n1boolean noneCs = students.stream().noneMatch(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()));\n\nfindFirstfindFirst用于返回满足条件的第一个元素，比如我们希望选出专业为土木工程的排在第一个学生，那么可以实现如下：\n1Optional&lt;Student&gt; optStu = students.stream().filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())).findFirst();\n\nfindFirst不携带参数，具体的查找条件可以通过filter设置，此外我们可以发现findFirst返回的是一个Optional类型，关于该类型的具体讲解可以参考上一篇：{ %post_link Java8新特性之Optional类 % }。\nfindAnyfindAny相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个，比如我们希望返回任意一个专业为土木工程的学生，可以实现如下：\n1Optional&lt;Student&gt; optStu = students.stream().filter(student -&gt; &quot;土木工程&quot;.equals(student.getMajor())).findAny();\n\n实际上对于顺序流式处理而言，findFirst和findAny返回的结果是一样的，至于为什么会这样设计，是因为在下一篇我们介绍的**并行流式处理**，当我们启用并行流式处理的时候，查找第一个元素往往会有很多限制，如果不是特别需求，在并行流式处理中使用findAny的性能要比findFirst好。\n3.2 归约前面的例子中我们大部分都是通过collect(Collectors.toList())对数据封装返回，如我的目标不是返回一个新的集合，而是希望对经过参数化操作后的集合进行进一步的运算，那么我们可用对集合实施归约操作。java8的流式处理提供了reduce方法来达到这一目的。\n前面我们通过mapToInt将Stream&lt;Student&gt;映射成为IntStream，并通过IntStream的sum方法求得所有学生的年龄之和，实际上我们通过归约操作，也可以达到这一目的，实现如下：\n123456789101112131415161718192021// 前面例子中的方法int totalAge = students.stream()                .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                .mapToInt(Student::getAge).sum();// 归约操作int totalAge = students.stream()                .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                .map(Student::getAge)                .reduce(0, (a, b) -&gt; a + b);// 进一步简化int totalAge2 = students.stream()                .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                .map(Student::getAge)                .reduce(0, Integer::sum);// 采用无初始值的重载版本，需要注意返回OptionalOptional&lt;Integer&gt; totalAge = students.stream()                .filter(student -&gt; &quot;计算机科学&quot;.equals(student.getMajor()))                .map(Student::getAge)                .reduce(Integer::sum);  // 去掉初始值\n\n3.3 收集前面利用collect(Collectors.toList())1是一个简单的收集操作，是对处理结果的封装，对应的还有toSet、toMap，以满足我们对于结果组织的需求。这些方法均来自于java.util.stream.Collectors&#96;，我们可以称之为收集器。\n3.3.1 归约收集器也提供了相应的归约操作，但是与reduce在内部实现上是有区别的，收集器更加适用于可变容器上的归约操作，这些收集器广义上均基于Collectors.reducing()实现。\n例1：求学生的总人数\n1234long count = students.stream().collect(Collectors.counting());// 进一步简化long count = students.stream().count();\n\n例2：求年龄的最大值和最小值\n12345678// 求最大年龄Optional&lt;Student&gt; olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -&gt; s1.getAge() - s2.getAge()));// 进一步简化Optional&lt;Student&gt; olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));// 求最小年龄Optional&lt;Student&gt; olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));\n\n例3：求年龄总和\n1int totalAge4 = students.stream().collect(Collectors.summingInt(Student::getAge));\n\n对应的还有summingLong、summingDouble。\n例4：求年龄的平均值\n1double avgAge = students.stream().collect(Collectors.averagingInt(Student::getAge));\n\n对应的还有averagingLong、averagingDouble。\n例5：一次性得到元素个数、总和、均值、最大值、最小值\n1IntSummaryStatistics statistics = students.stream().collect(Collectors.summarizingInt(Student::getAge));\n\n输出：\n1IntSummaryStatistics&#123;count=10, sum=220, min=20, average=22.000000, max=24&#125;\n\n对应的还有summarizingLong、summarizingDouble。\n例6：字符串拼接\n1234String names = students.stream().map(Student::getName).collect(Collectors.joining());// 输出：孔明伯约玄德云长翼德元直奉孝仲谋鲁肃丁奉String names = students.stream().map(Student::getName).collect(Collectors.joining(&quot;, &quot;));// 输出：孔明, 伯约, 玄德, 云长, 翼德, 元直, 奉孝, 仲谋, 鲁肃, 丁奉\n\n3.3.2 分组在数据库操作中，我们可以通过GROUP BY关键字对查询到的数据进行分组，java8的流式处理也为我们提供了这样的功能Collectors.groupingBy来操作集合。比如我们可以按学校对上面的学生进行分组：\n1Map&lt;String, List&lt;Student&gt;&gt; groups = students.stream().collect(Collectors.groupingBy(Student::getSchool));\n\ngroupingBy接收一个分类器Function&lt;? super T, ? extends K&gt; classifier，我们可以自定义分类器来实现需要的分类效果。\n上面演示的是一级分组，我们还可以定义多个分类器实现多级分组，比如我们希望在按学校分组的基础之上再按照专业进行分组，实现如下：\n123Map&lt;String, Map&lt;String, List&lt;Student&gt;&gt;&gt; groups2 = students.stream().collect(                Collectors.groupingBy(Student::getSchool,  // 一级分组，按学校                Collectors.groupingBy(Student::getMajor)));  // 二级分组，按专业\n\n实际上在groupingBy的第二个参数不是只能传递groupingBy，还可以传递任意Collector类型，比如我们可以传递一个Collector.counting，用以统计每个组的个数：\n1Map&lt;String, Long&gt; groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));\n\n如果我们不添加第二个参数，则编译器会默认帮我们添加一个Collectors.toList()。\n3.3.3 分区分区可以看做是分组的一种特殊情况，在分区中key只有两种情况：true或false，目的是将待分区集合按照条件一分为二，java8的流式处理利用Collectors.partitioningBy()方法实现分区，该方法接收一个谓词，例如我们希望将学生分为武大学生和非武大学生，那么可以实现如下：\n1Map&lt;Boolean, List&lt;Student&gt;&gt; partition = students.stream().collect(Collectors.partitioningBy(student -&gt; &quot;武汉大学&quot;.equals(student.getSchool())));\n\n分区相对分组的优势在于，我们可以同时得到两类结果，在一些应用场景下可以一步得到我们需要的所有结果，比如将数组分为奇数和偶数。\n以上介绍的所有收集器均实现自接口java.util.stream.Collector，该接口的定义如下：\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public interface Collector&lt;T, A, R&gt; &#123;    /**     * A function that creates and returns a new mutable result container.     *     * @return a function which returns a new, mutable result container     */    Supplier&lt;A&gt; supplier();    /**     * A function that folds a value into a mutable result container.     *     * @return a function which folds a value into a mutable result container     */    BiConsumer&lt;A, T&gt; accumulator();    /**     * A function that accepts two partial results and merges them.  The     * combiner function may fold state from one argument into the other and     * return that, or may return a new result container.     *     * @return a function which combines two partial results into a combined     * result     */    BinaryOperator&lt;A&gt; combiner();    /**     * Perform the final transformation from the intermediate accumulation type     * &#123;@code A&#125; to the final result type &#123;@code R&#125;.     *     * &lt;p&gt;If the characteristic &#123;@code IDENTITY_TRANSFORM&#125; is     * set, this function may be presumed to be an identity transform with an     * unchecked cast from &#123;@code A&#125; to &#123;@code R&#125;.     *     * @return a function which transforms the intermediate result to the final     * result     */    Function&lt;A, R&gt; finisher();    /**     * Returns a &#123;@code Set&#125; of &#123;@code Collector.Characteristics&#125; indicating     * the characteristics of this Collector.  This set should be immutable.     *     * @return an immutable set of collector characteristics     */    Set&lt;Characteristics&gt; characteristics();&#125;\n\n我们也可以实现该接口来定义自己的收集器，此处不再展开。\n四. 并行流式数据处理流式处理中的很多都适合采用 分而治之 的思想，从而在处理集合较大时，极大的提高代码的性能，java8的设计者也看到了这一点，所以提供了并行流式处理。上面的例子中我们都是调用stream()方法来启动流式处理，java8还提供了parallelStream()来启动并行流式处理，parallelStream()本质上基于java7的Fork-Join框架实现，其默认的线程数为宿主机的内核数。\n启动并行流式处理虽然简单，只需要将stream()替换成parallelStream()即可，但既然是并行，就会涉及到多线程安全问题，所以在启用之前要先确认并行是否值得（并行的效率不一定高于顺序执行），另外就是要保证线程安全。此两项无法保证，那么并行毫无意义，毕竟结果比速度更加重要，以后有时间再来详细分析一下并行流式数据处理的具体实现和最佳实践。","dateCreated":"2018-06-20T19:39:11+08:00","dateModified":"2024-09-01T21:23:26+08:00","datePublished":"2018-06-20T19:39:11+08:00","description":"java8的流式处理极大了简化我们对于集合、数组等结构的操作，让我们可以以函数式的思想去操作，本篇文章将探讨java8的流式数据处理的基本使用。","headline":"Java8新特性之流式数据处理","image":["https://api.dujin.org/bing/1366.php","http://pic.tsmp4.net/api/fengjing/img.php"],"mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.biwin.eu.org/posts/df816e2e.html"},"publisher":{"@type":"Organization","name":"Mr.WangLi","sameAs":["https://github.com/biwin-wangli","http://stackoverflow.com/users","https://www.linkedin.com/profile/","mailto:274027703@qq.com"],"image":"https://img.biwin.eu.org/touxiang.jpeg","logo":{"@type":"ImageObject","url":"https://img.biwin.eu.org/touxiang.jpeg"}},"url":"https://blog.biwin.eu.org/posts/df816e2e.html","keywords":"Java","thumbnailUrl":"https://api.dujin.org/bing/1366.php"}</script>
    <meta name="description" content="Java8新特性之流式数据处理">
<meta property="og:type" content="blog">
<meta property="og:title" content="Java8新特性之流式数据处理">
<meta property="og:url" content="https://blog.biwin.eu.org/posts/df816e2e.html">
<meta property="og:site_name" content="BiWin&#39;s Blog">
<meta property="og:description" content="Java8新特性之流式数据处理">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://5b868fd.webp.li/stream-1.png">
<meta property="article:published_time" content="2018-06-20T11:39:11.000Z">
<meta property="article:modified_time" content="2024-09-01T13:23:26.445Z">
<meta property="article:author" content="Mr.WangLi">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://5b868fd.webp.li/stream-1.png">
    
    
        
    
    
        <meta property="og:image" content="https://img.biwin.eu.org/touxiang.jpeg"/>
    
    
        <meta property="og:image" content="https://api.dujin.org/bing/1366.php"/>
        <meta class="swiftype" name="image" data-type="enum" content="https://api.dujin.org/bing/1366.php"/>
    
    
        <meta property="og:image" content="http://pic.tsmp4.net/api/fengjing/img.php"/>
        <meta class="swiftype" name="image" data-type="enum" content="http://pic.tsmp4.net/api/fengjing/img.php"/>
    
    
    <!--STYLES-->
    
<link rel="stylesheet" href="/assets/css/style-vfgvchqkdym9obx7tmwvvzqxiypypaaj66luf6y7bb4kfhuqzb8eonjh8v3p.min.css">

    <!--STYLES END-->
    

    

    
        
    
</head>

    <body>
        <div id="blog">
            <!-- Define author's picture -->


    
        
            
        
    

<header id="header" data-behavior="4">
    <i id="btn-open-sidebar" class="fa fa-lg fa-bars"></i>
    <div class="header-title">
        <a
            class="header-title-link"
            href="/"
            aria-label=""
        >
            BiWin&#39;s Blog
        </a>
    </div>
    
        
            <a
                class="header-right-picture "
                href="#about"
                aria-label="打开链接: /#about"
            >
        
        
            <img class="header-picture" src="https://img.biwin.eu.org/touxiang.jpeg" alt="作者的图片"/>
        
        </a>
    
</header>

            <!-- Define author's picture -->



        
    

<nav id="sidebar" data-behavior="4">
    <div class="sidebar-container">
        
            <div class="sidebar-profile">
                <a
                    href="/#about"
                    aria-label="阅读有关作者的更多信息"
                >
                    <img class="sidebar-profile-picture" src="https://img.biwin.eu.org/touxiang.jpeg" alt="作者的图片"/>
                </a>
                <h4 class="sidebar-profile-name">Mr.WangLi</h4>
                
                    <h5 class="sidebar-profile-bio"><p>喜欢技术，喜欢一个人！</p>
</h5>
                
            </div>
        
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/"
                            
                            rel="noopener"
                            title="首页"
                        >
                        <i class="sidebar-button-icon fa fa-home" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">首页</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-categories"
                            
                            rel="noopener"
                            title="分类"
                        >
                        <i class="sidebar-button-icon fa fa-bookmark" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">分类</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-tags"
                            
                            rel="noopener"
                            title="标签"
                        >
                        <i class="sidebar-button-icon fa fa-tags" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">标签</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="/all-archives"
                            
                            rel="noopener"
                            title="归档"
                        >
                        <i class="sidebar-button-icon fa fa-archive" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">归档</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link open-algolia-search"
                            href="#search"
                            
                            rel="noopener"
                            title="搜索"
                        >
                        <i class="sidebar-button-icon fa fa-search" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">搜索</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="#about"
                            
                            rel="noopener"
                            title="关于"
                        >
                        <i class="sidebar-button-icon fa fa-question" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">关于</span>
                    </a>
            </li>
            
        </ul>
        
            <ul class="sidebar-buttons">
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://github.com/biwin-wangli"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="GitHub"
                        >
                        <i class="sidebar-button-icon fab fa-github" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">GitHub</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="http://stackoverflow.com/users"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="Stack Overflow"
                        >
                        <i class="sidebar-button-icon fab fa-stack-overflow" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">Stack Overflow</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="https://www.linkedin.com/profile/"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="LinkedIn"
                        >
                        <i class="sidebar-button-icon fab fa-linkedin" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">LinkedIn</span>
                    </a>
            </li>
            
                <li class="sidebar-button">
                    
                        <a
                            class="sidebar-button-link "
                            href="mailto:274027703@qq.com"
                            
                                target="_blank"
                            
                            rel="noopener"
                            title="邮箱"
                        >
                        <i class="sidebar-button-icon fa fa-envelope" aria-hidden="true"></i>
                        <span class="sidebar-button-desc">邮箱</span>
                    </a>
            </li>
            
        </ul>
        
        <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&id=3132987672&auto=1&height=90"></iframe>
    </div>
</nav>

            
        <div class="post-header-cover
                    text-center
                    post-header-cover--full"
             style="background-image:url('http://pic.tsmp4.net/api/fengjing/img.php');"
             data-behavior="4">
            
                <div class="post-header main-content-wrap text-center">
    
        <h1 class="post-title">
            Java8新特性之流式数据处理
        </h1>
    
    
        <div class="post-meta">
    <time datetime="2018-06-20T19:39:11+08:00">
	
		    2018 年 6 月 20 日
    	
    </time>
    
        <span>发布在 </span>
        
    <a class="category-link" href="/categories/JDK8/">JDK8</a>, <a class="category-link" href="/categories/JDK8/Basics/">Basics</a>


    
</div>

        
    
    
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_page_pv" style='display:none' class="post-meta">
	        <i class="icon-smile icon"></i> 阅读数：<span id="busuanzi_value_page_pv"></span>次
	    </span>
    
</div>

            
        </div>

            <div id="main" data-behavior="4"
                 class="hasCover
                        hasCoverMetaIn
                        hasCoverCaption">
                
<article class="post">
    
        <span class="post-header-cover-caption caption">再繁忙的学习，也需要静一会下来，放松自己，欣赏美丽的风景</span>
    
    
    <div class="post-content markdown">
        <div class="main-content-wrap">
            <!-- excerpt -->
<h1 id="table-of-contents">目录</h1><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E6%B5%81%E5%BC%8F%E5%A4%84%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-text">一. 流式处理简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C"><span class="toc-text">二. 中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%BF%87%E6%BB%A4"><span class="toc-text">2.1 过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#distinct"><span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skip"><span class="toc-text">skip</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%98%A0%E5%B0%84"><span class="toc-text">2.2 映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flatMap"><span class="toc-text">flatMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C"><span class="toc-text">三. 终端操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%9F%A5%E6%89%BE"><span class="toc-text">3.1 查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#allMatch"><span class="toc-text">allMatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#anyMatch"><span class="toc-text">anyMatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#noneMathch"><span class="toc-text">noneMathch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findFirst"><span class="toc-text">findFirst</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#findAny"><span class="toc-text">findAny</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%BD%92%E7%BA%A6"><span class="toc-text">3.2 归约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%94%B6%E9%9B%86"><span class="toc-text">3.3 收集</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-%E5%BD%92%E7%BA%A6"><span class="toc-text">3.3.1 归约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-%E5%88%86%E7%BB%84"><span class="toc-text">3.3.2 分组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-%E5%88%86%E5%8C%BA"><span class="toc-text">3.3.3 分区</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%B9%B6%E8%A1%8C%E6%B5%81%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86"><span class="toc-text">四. 并行流式数据处理</span></a></li></ol>

<h2 id="一-流式处理简介"><a href="#一-流式处理简介" class="headerlink" title="一. 流式处理简介"></a>一. 流式处理简介</h2><p>在我接触到java8流式处理的时候，我的第一感觉是流式处理让集合操作变得简洁了许多，通常我们需要多行代码才能完成的操作，借助于流式处理可以在一行中实现。比如我们希望对一个包含整数的集合中筛选出所有的偶数，并将其封装成为一个新的List返回，那么在java8之前，我们需要通过如下代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; evens = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">final</span> Integer num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        evens.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过java8的流式处理，我们可以将代码简化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; evens = nums.stream().filter(num -&gt; num % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>先简单解释一下上面这行语句的含义，<code>stream()</code>操作将集合转换成一个流，<code>filter()</code>执行我们自定义的筛选处理，这里是通过lambda表达式筛选出所有偶数，最后我们通过<br><code>collect()</code>对结果进行封装处理，并通过<code>Collectors.toList()</code>指定其封装成为一个List集合返回。</p>
<p>由上面的例子可以看出，java8的流式处理极大的简化了对于集合的操作，实际上不光是集合，包括数组、文件等，只要是可以转换成流，我们都可以借助流式处理，类似于我们写SQL语句一样对其进行操作。java8通过内部迭代来实现对流的处理，一个流式处理可以分为三个部分：转换成流、中间操作、终端操作。如下图：<br><img src="https://5b868fd.webp.li/stream-1.png" alt="image.png"><br>以集合为例，一个流式处理的操作我们首先需要调用<code>stream()</code>函数将其转换成流，然后再调用相应的<code>中间操作</code><br>达到我们需要对集合进行的操作，比如筛选、转换等，最后通过<code>终端操作</code>对前面的结果进行封装，返回我们需要的形式。</p>
<h2 id="二-中间操作"><a href="#二-中间操作" class="headerlink" title="二. 中间操作"></a>二. 中间操作</h2><p>我们定义一个简单的学生实体类，用于后面的例子演示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 学号 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 年级 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> grade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 专业 */</span></span><br><span class="line">    <span class="keyword">private</span> String major;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 学校 */</span></span><br><span class="line">    <span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略getter和setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">List&lt;Student&gt; students = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20160001</span>, <span class="string">&quot;孔明&quot;</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="string">&quot;土木工程&quot;</span>, <span class="string">&quot;武汉大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20160002</span>, <span class="string">&quot;伯约&quot;</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="string">&quot;信息安全&quot;</span>, <span class="string">&quot;武汉大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20160003</span>, <span class="string">&quot;玄德&quot;</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="string">&quot;经济管理&quot;</span>, <span class="string">&quot;武汉大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20160004</span>, <span class="string">&quot;云长&quot;</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="string">&quot;信息安全&quot;</span>, <span class="string">&quot;武汉大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20161001</span>, <span class="string">&quot;翼德&quot;</span>, <span class="number">21</span>, <span class="number">2</span>, <span class="string">&quot;机械与自动化&quot;</span>, <span class="string">&quot;华中科技大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20161002</span>, <span class="string">&quot;元直&quot;</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="string">&quot;土木工程&quot;</span>, <span class="string">&quot;华中科技大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20161003</span>, <span class="string">&quot;奉孝&quot;</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="string">&quot;计算机科学&quot;</span>, <span class="string">&quot;华中科技大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20162001</span>, <span class="string">&quot;仲谋&quot;</span>, <span class="number">22</span>, <span class="number">3</span>, <span class="string">&quot;土木工程&quot;</span>, <span class="string">&quot;浙江大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20162002</span>, <span class="string">&quot;鲁肃&quot;</span>, <span class="number">23</span>, <span class="number">4</span>, <span class="string">&quot;计算机科学&quot;</span>, <span class="string">&quot;浙江大学&quot;</span>));</span><br><span class="line">        add(<span class="keyword">new</span> <span class="title class_">Student</span>(<span class="number">20163001</span>, <span class="string">&quot;丁奉&quot;</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="string">&quot;土木工程&quot;</span>, <span class="string">&quot;南京大学&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-过滤"><a href="#2-1-过滤" class="headerlink" title="2.1 过滤"></a>2.1 过滤</h3><p>过滤，顾名思义就是按照给定的要求对集合进行筛选满足条件的元素，java8提供的筛选操作包括：filter、distinct、limit、skip。</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>在前面的例子中我们已经演示了如何使用filter，其定义为：<code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code>，filter接受一个谓词<br><code>Predicate</code>，我们可以通过这个谓词定义筛选条件，在介绍lambda表达式时我们介绍过<code>Predicate</code>是一个函数式接口，其包含一个<br><code>test(T t)</code>方法，该方法返回<code>boolean</code>。现在我们希望从集合<code>students</code>中筛选出所有武汉大学的学生，那么我们可以通过filter来实现，并将筛选操作作为参数传递给filter：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; whuStudents = students.stream()</span><br><span class="line">                                    .filter(student -&gt; <span class="string">&quot;武汉大学&quot;</span>.equals(student.getSchool()))</span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>distinct操作类似于我们在写SQL语句时，添加的<code>DISTINCT</code>关键字，用于去重处理，distinct基于<code>Object.equals(Object)</code><br>实现，回到最开始的例子，假设我们希望筛选出所有不重复的偶数，那么可以添加distinct操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; evens = nums.stream()</span><br><span class="line">                        .filter(num -&gt; num % <span class="number">2</span> == <span class="number">0</span>).distinct()</span><br><span class="line">                        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>limit操作也类似于SQL语句中的<code>LIMIT</code>关键字，不过相对功能较弱，limit返回包含前n个元素的流，当集合大小小于n时，则返回实际长度，比如下面的例子返回前两个专业为<br><code>土木工程</code>专业的学生：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; civilStudents = students.stream()</span><br><span class="line">                                    .filter(student -&gt; <span class="string">&quot;土木工程&quot;</span>.equals(student.getMajor())).limit(<span class="number">2</span>)</span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>说到limit，不得不提及一下另外一个流操作：sorted。该操作用于对流中元素进行排序，<code>sorted</code>要求待比较的元素必须实现<code>Comparable</code><br>接口，如果没有实现也不要紧，我们可以将比较器作为参数传递给<code>sorted(Comparator&lt;? super T&gt; comparator)</code><br>，比如我们希望筛选出专业为土木工程的学生，并按年龄从小到大排序，筛选出年龄最小的两个学生，那么可以实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; sortedCivilStudents = students.stream()</span><br><span class="line">                                            .filter(student -&gt; <span class="string">&quot;土木工程&quot;</span>.equals(student.getMajor())).sorted((s1, s2) -&gt; s1.getAge() - s2.getAge())</span><br><span class="line">                                            .limit(<span class="number">2</span>)</span><br><span class="line">                                            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p>skip操作与limit操作相反，如同其字面意思一样，是跳过前n个元素，比如我们希望找出排序在2之后的土木工程专业的学生，那么可以实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Student&gt; civilStudents = students.stream()</span><br><span class="line">                                    .filter(student -&gt; <span class="string">&quot;土木工程&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                                    .skip(<span class="number">2</span>)</span><br><span class="line">                                    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>通过skip，就会跳过前面两个元素，返回由后面所有元素构造的流，如果n大于满足条件的集合的长度，则会返回一个空的集合。</p>
<h3 id="2-2-映射"><a href="#2-2-映射" class="headerlink" title="2.2 映射"></a>2.2 映射</h3><p>在SQL中，借助<code>SELECT</code>关键字后面添加需要的字段名称，可以仅输出我们需要的字段数据，而流式处理的映射操作也是实现这一目的，在java8的流式处理中，主要包含两类映射操作：map和flatMap。</p>
<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>举例说明，假设我们希望筛选出所有专业为计算机科学的学生姓名，那么我们可以在filter筛选的基础之上，通过map将学生实体映射成为学生姓名字符串，具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = students.stream()</span><br><span class="line">                            .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                            .map(Student::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>除了上面这类基础的map，java8还提供了<code>mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</code>，<br><code>mapToInt(ToIntFunction&lt;? super T&gt; mapper)</code>，<code>mapToLong(ToLongFunction&lt;? super T&gt; mapper)</code><br>，这些映射分别返回对应类型的流，java8为这些流设定了一些特殊的操作，比如我们希望计算所有专业为计算机科学学生的年龄之和，那么我们可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalAge</span> <span class="operator">=</span> students.stream()</span><br><span class="line">                    .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                    .mapToInt(Student::getAge).sum();</span><br></pre></td></tr></table></figure>

<p>通过将Student按照年龄直接映射为<code>IntStream</code>，我们可以直接调用提供的<code>sum()</code>方法来达到目的，此外使用这些数值流的好处还在于可以避免jvm装箱操作所带来的性能消耗。</p>
<h4 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h4><p>flatMap与map的区别在于<strong>flatMap是将一个流中的每个值都转成一个个流，然后再将这些流扁平化成为一个流</strong>。举例说明，假设我们有一个字符串数组<br><code>String[] strs = &#123;&quot;java8&quot;, &quot;is&quot;, &quot;easy&quot;, &quot;to&quot;, &quot;use&quot;&#125;;</code>，我们希望输出构成这一数组的所有非重复字符，那么我们可能首先会想到如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String[]&gt; distinctStrs = Arrays.stream(strs)</span><br><span class="line">                                .map(str -&gt; str.split(<span class="string">&quot;&quot;</span>))  <span class="comment">// 映射成为Stream&lt;String[]&gt;</span></span><br><span class="line">                                .distinct()</span><br><span class="line">                                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>在执行map操作以后，我们得到是一个包含多个字符串（构成一个字符串的字符数组）的流，此时执行distinct操作是基于在这些字符串数组之间的对比，所以达不到我们希望的目的，此时的输出为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[j, a, v, a, <span class="number">8</span>]</span><br><span class="line">[i, s]</span><br><span class="line">[e, a, s, y]</span><br><span class="line">[t, o]</span><br><span class="line">[u, s, e]</span><br></pre></td></tr></table></figure>

<p>distinct只有对于一个包含多个字符的流进行操作才能达到我们的目的，即对<code>Stream&lt;String&gt;</code>进行操作。此时flatMap就可以达到我们的目的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; distinctStrs = Arrays.stream(strs)</span><br><span class="line">                                .map(str -&gt; str.split(<span class="string">&quot;&quot;</span>))  <span class="comment">// 映射成为Stream&lt;String[]&gt;</span></span><br><span class="line">                                .flatMap(Arrays::stream)  <span class="comment">// 扁平化为Stream&lt;String&gt;</span></span><br><span class="line">                                .distinct()</span><br><span class="line">                                .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>flatMap将由map映射得到的Stream&lt;String[]&gt;，转换成由各个字符串数组映射成的流Stream<String><br>，再将这些小的流扁平化成为一个由所有字符串构成的大流Steam<String>，从而能够达到我们的目的。<br>与map类似，flatMap也提供了针对特定类型的映射操作：<code>flatMapToDouble(Function&lt;? super T,? extends DoubleStream&gt; mapper)</code>，<br><code>flatMapToInt(Function&lt;? super T,? extends IntStream&gt; mapper)</code>，<br><code>flatMapToLong(Function&lt;? super T,? extends LongStream&gt; mapper)</code>。</p>
<h2 id="三-终端操作"><a href="#三-终端操作" class="headerlink" title="三. 终端操作"></a>三. 终端操作</h2><p>终端操作是流式处理的最后一步，我们可以在终端操作中实现对流查找、归约等操作。</p>
<h3 id="3-1-查找"><a href="#3-1-查找" class="headerlink" title="3.1 查找"></a>3.1 查找</h3><h4 id="allMatch"><a href="#allMatch" class="headerlink" title="allMatch"></a>allMatch</h4><p>allMatch用于检测是否全部都满足指定的参数行为，如果全部满足则返回true，例如我们希望检测是否所有的学生都已满18周岁，那么可以实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isAdult</span> <span class="operator">=</span> students.stream().allMatch(student -&gt; student.getAge() &gt;= <span class="number">18</span>);</span><br></pre></td></tr></table></figure>

<h4 id="anyMatch"><a href="#anyMatch" class="headerlink" title="anyMatch"></a>anyMatch</h4><p>anyMatch则是检测是否存在一个或多个满足指定的参数行为，如果满足则返回true，例如我们希望检测是否有来自武汉大学的学生，那么可以实现为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">hasWhu</span> <span class="operator">=</span> students.stream().anyMatch(student -&gt; <span class="string">&quot;武汉大学&quot;</span>.equals(student.getSchool()));</span><br></pre></td></tr></table></figure>

<h4 id="noneMathch"><a href="#noneMathch" class="headerlink" title="noneMathch"></a>noneMathch</h4><p>noneMatch用于检测是否不存在满足指定行为的元素，如果不存在则返回true，例如我们希望检测是否不存在专业为计算机科学的学生，可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">noneCs</span> <span class="operator">=</span> students.stream().noneMatch(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()));</span><br></pre></td></tr></table></figure>

<h4 id="findFirst"><a href="#findFirst" class="headerlink" title="findFirst"></a>findFirst</h4><p>findFirst用于返回满足条件的第一个元素，比如我们希望选出专业为土木工程的排在第一个学生，那么可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; optStu = students.stream().filter(student -&gt; <span class="string">&quot;土木工程&quot;</span>.equals(student.getMajor())).findFirst();</span><br></pre></td></tr></table></figure>

<p>findFirst不携带参数，具体的查找条件可以通过filter设置，此外我们可以发现findFirst返回的是一个Optional类型，关于该类型的具体讲解可以参考上一篇：{ %<br>post_link Java8新特性之Optional类 % }。</p>
<h4 id="findAny"><a href="#findAny" class="headerlink" title="findAny"></a>findAny</h4><p>findAny相对于findFirst的区别在于，findAny不一定返回第一个，而是返回任意一个，比如我们希望返回任意一个专业为土木工程的学生，可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Student&gt; optStu = students.stream().filter(student -&gt; <span class="string">&quot;土木工程&quot;</span>.equals(student.getMajor())).findAny();</span><br></pre></td></tr></table></figure>

<p>实际上对于顺序流式处理而言，findFirst和findAny返回的结果是一样的，至于为什么会这样设计，是因为在下一篇我们介绍的**并行流式处理<br>**，当我们启用并行流式处理的时候，查找第一个元素往往会有很多限制，如果不是特别需求，在并行流式处理中使用findAny的性能要比findFirst好。</p>
<h3 id="3-2-归约"><a href="#3-2-归约" class="headerlink" title="3.2 归约"></a>3.2 归约</h3><p>前面的例子中我们大部分都是通过<code>collect(Collectors.toList())</code><br>对数据封装返回，如我的目标不是返回一个新的集合，而是希望对经过参数化操作后的集合进行进一步的运算，那么我们可用对集合实施归约操作。java8的流式处理提供了<br><code>reduce</code>方法来达到这一目的。</p>
<p>前面我们通过mapToInt将<code>Stream&lt;Student&gt;</code>映射成为<code>IntStream</code>，并通过<code>IntStream</code><br>的sum方法求得所有学生的年龄之和，实际上我们通过归约操作，也可以达到这一目的，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前面例子中的方法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalAge</span> <span class="operator">=</span> students.stream()</span><br><span class="line">                .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                .mapToInt(Student::getAge).sum();</span><br><span class="line"><span class="comment">// 归约操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalAge</span> <span class="operator">=</span> students.stream()</span><br><span class="line">                .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                .map(Student::getAge)</span><br><span class="line">                .reduce(<span class="number">0</span>, (a, b) -&gt; a + b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步简化</span></span><br><span class="line"><span class="type">int</span> <span class="variable">totalAge2</span> <span class="operator">=</span> students.stream()</span><br><span class="line">                .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                .map(Student::getAge)</span><br><span class="line">                .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 采用无初始值的重载版本，需要注意返回Optional</span></span><br><span class="line">Optional&lt;Integer&gt; totalAge = students.stream()</span><br><span class="line">                .filter(student -&gt; <span class="string">&quot;计算机科学&quot;</span>.equals(student.getMajor()))</span><br><span class="line">                .map(Student::getAge)</span><br><span class="line">                .reduce(Integer::sum);  <span class="comment">// 去掉初始值</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-收集"><a href="#3-3-收集" class="headerlink" title="3.3 收集"></a>3.3 收集</h3><p>前面利用<code>collect(Collectors.toList())1是一个简单的收集操作，是对处理结果的封装，对应的还有</code>toSet<code>、</code>toMap<br><code>，以满足我们对于结果组织的需求。这些方法均来自于</code>java.util.stream.Collectors&#96;，我们可以称之为收集器。</p>
<h4 id="3-3-1-归约"><a href="#3-3-1-归约" class="headerlink" title="3.3.1 归约"></a>3.3.1 归约</h4><p>收集器也提供了相应的归约操作，但是与reduce在内部实现上是有区别的，收集器更加适用于可变容器上的归约操作，这些收集器广义上均基于<br><code>Collectors.reducing()</code>实现。</p>
<p>例1：求学生的总人数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> students.stream().collect(Collectors.counting());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步简化</span></span><br><span class="line"><span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> students.stream().count();</span><br></pre></td></tr></table></figure>

<p>例2：求年龄的最大值和最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求最大年龄</span></span><br><span class="line">Optional&lt;Student&gt; olderStudent = students.stream().collect(Collectors.maxBy((s1, s2) -&gt; s1.getAge() - s2.getAge()));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进一步简化</span></span><br><span class="line">Optional&lt;Student&gt; olderStudent2 = students.stream().collect(Collectors.maxBy(Comparator.comparing(Student::getAge)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求最小年龄</span></span><br><span class="line">Optional&lt;Student&gt; olderStudent3 = students.stream().collect(Collectors.minBy(Comparator.comparing(Student::getAge)));</span><br></pre></td></tr></table></figure>

<p>例3：求年龄总和</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">totalAge4</span> <span class="operator">=</span> students.stream().collect(Collectors.summingInt(Student::getAge));</span><br></pre></td></tr></table></figure>

<p>对应的还有<code>summingLong</code>、<code>summingDouble</code>。</p>
<p>例4：求年龄的平均值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">avgAge</span> <span class="operator">=</span> students.stream().collect(Collectors.averagingInt(Student::getAge));</span><br></pre></td></tr></table></figure>

<p>对应的还有<code>averagingLong</code>、<code>averagingDouble</code>。</p>
<p>例5：一次性得到元素个数、总和、均值、最大值、最小值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">IntSummaryStatistics</span> <span class="variable">statistics</span> <span class="operator">=</span> students.stream().collect(Collectors.summarizingInt(Student::getAge));</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IntSummaryStatistics&#123;count=<span class="number">10</span>, sum=<span class="number">220</span>, min=<span class="number">20</span>, average=<span class="number">22.000000</span>, max=<span class="number">24</span>&#125;</span><br></pre></td></tr></table></figure>

<p>对应的还有<code>summarizingLong</code>、<code>summarizingDouble</code>。</p>
<p>例6：字符串拼接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> students.stream().map(Student::getName).collect(Collectors.joining());</span><br><span class="line"><span class="comment">// 输出：孔明伯约玄德云长翼德元直奉孝仲谋鲁肃丁奉</span></span><br><span class="line"><span class="type">String</span> <span class="variable">names</span> <span class="operator">=</span> students.stream().map(Student::getName).collect(Collectors.joining(<span class="string">&quot;, &quot;</span>));</span><br><span class="line"><span class="comment">// 输出：孔明, 伯约, 玄德, 云长, 翼德, 元直, 奉孝, 仲谋, 鲁肃, 丁奉</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-分组"><a href="#3-3-2-分组" class="headerlink" title="3.3.2 分组"></a>3.3.2 分组</h4><p>在数据库操作中，我们可以通过<code>GROUP BY</code>关键字对查询到的数据进行分组，java8的流式处理也为我们提供了这样的功能<br><code>Collectors.groupingBy</code>来操作集合。比如我们可以按学校对上面的学生进行分组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; groups = students.stream().collect(Collectors.groupingBy(Student::getSchool));</span><br></pre></td></tr></table></figure>

<p><code>groupingBy</code>接收一个分类器<code>Function&lt;? super T, ? extends K&gt; classifier</code>，我们可以自定义分类器来实现需要的分类效果。</p>
<p>上面演示的是一级分组，我们还可以定义多个分类器实现<strong>多级分组</strong>，比如我们希望在按学校分组的基础之上再按照专业进行分组，实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Map&lt;String, List&lt;Student&gt;&gt;&gt; groups2 = students.stream().collect(</span><br><span class="line">                Collectors.groupingBy(Student::getSchool,  <span class="comment">// 一级分组，按学校</span></span><br><span class="line">                Collectors.groupingBy(Student::getMajor)));  <span class="comment">// 二级分组，按专业</span></span><br></pre></td></tr></table></figure>

<p>实际上在<code>groupingBy</code>的第二个参数不是只能传递groupingBy，还可以传递任意<code>Collector</code>类型，比如我们可以传递一个<br><code>Collector.counting</code>，用以统计每个组的个数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; groups = students.stream().collect(Collectors.groupingBy(Student::getSchool, Collectors.counting()));</span><br></pre></td></tr></table></figure>

<p>如果我们不添加第二个参数，则编译器会默认帮我们添加一个<code>Collectors.toList()</code>。</p>
<h4 id="3-3-3-分区"><a href="#3-3-3-分区" class="headerlink" title="3.3.3 分区"></a>3.3.3 分区</h4><p>分区可以看做是分组的一种特殊情况，在分区中key只有两种情况：true或false，目的是将待分区集合按照条件一分为二，java8的流式处理利用<br><code>Collectors.partitioningBy()</code>方法实现分区，该方法接收一个谓词，例如我们希望将学生分为武大学生和非武大学生，那么可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; partition = students.stream().collect(Collectors.partitioningBy(student -&gt; <span class="string">&quot;武汉大学&quot;</span>.equals(student.getSchool())));</span><br></pre></td></tr></table></figure>

<p>分区相对分组的优势在于，我们可以同时得到两类结果，在一些应用场景下可以一步得到我们需要的所有结果，比如将数组分为奇数和偶数。</p>
<p>以上介绍的所有收集器均实现自接口<code>java.util.stream.Collector</code>，该接口的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Collector</span>&lt;T, A, R&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that creates and returns a new mutable result container.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function which returns a new, mutable result container</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Supplier&lt;A&gt; <span class="title function_">supplier</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that folds a value into a mutable result container.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function which folds a value into a mutable result container</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BiConsumer&lt;A, T&gt; <span class="title function_">accumulator</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * A function that accepts two partial results and merges them.  The</span></span><br><span class="line"><span class="comment">     * combiner function may fold state from one argument into the other and</span></span><br><span class="line"><span class="comment">     * return that, or may return a new result container.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function which combines two partial results into a combined</span></span><br><span class="line"><span class="comment">     * result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BinaryOperator&lt;A&gt; <span class="title function_">combiner</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Perform the final transformation from the intermediate accumulation type</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> A&#125; to the final result type &#123;<span class="doctag">@code</span> R&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If the characteristic &#123;<span class="doctag">@code</span> IDENTITY_TRANSFORM&#125; is</span></span><br><span class="line"><span class="comment">     * set, this function may be presumed to be an identity transform with an</span></span><br><span class="line"><span class="comment">     * unchecked cast from &#123;<span class="doctag">@code</span> A&#125; to &#123;<span class="doctag">@code</span> R&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function which transforms the intermediate result to the final</span></span><br><span class="line"><span class="comment">     * result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Function&lt;A, R&gt; <span class="title function_">finisher</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a &#123;<span class="doctag">@code</span> Set&#125; of &#123;<span class="doctag">@code</span> Collector.Characteristics&#125; indicating</span></span><br><span class="line"><span class="comment">     * the characteristics of this Collector.  This set should be immutable.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an immutable set of collector characteristics</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;Characteristics&gt; <span class="title function_">characteristics</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们也可以实现该接口来定义自己的收集器，此处不再展开。</p>
<h2 id="四-并行流式数据处理"><a href="#四-并行流式数据处理" class="headerlink" title="四. 并行流式数据处理"></a>四. 并行流式数据处理</h2><p>流式处理中的很多都适合采用 分而治之 的思想，从而在处理集合较大时，极大的提高代码的性能，java8的设计者也看到了这一点，所以提供了<br>并行流式处理。上面的例子中我们都是调用<code>stream()</code>方法来启动流式处理，java8还提供了<code>parallelStream()</code>来启动并行流式处理，<br><code>parallelStream()</code>本质上基于java7的Fork-Join框架实现，其默认的线程数为宿主机的内核数。</p>
<p>启动并行流式处理虽然简单，只需要将<code>stream()</code>替换成<code>parallelStream()</code><br>即可，但既然是并行，就会涉及到多线程安全问题，所以在启用之前要先确认并行是否值得（并行的效率不一定高于顺序执行），另外就是要保证线程安全。此两项无法保证，那么并行毫无意义，毕竟结果比速度更加重要，以后有时间再来详细分析一下并行流式数据处理的具体实现和最佳实践。</p>
            


        </div>
    </div>
    <br/>
    <!-- 添加的部分 -->
    <!-- copyright -->
    
        <style>
.article-footer-copyright {
	border-left-color: #f66;
	padding: 12px 24px 12px 30px;
    margin: 2em 0;
    border-left-width: 4px;
    border-left-style: solid;
    background-color: #f8f8f8;
    position: relative;
    border-bottom-right-radius: 2px;
    border-top-right-radius: 2px;
	margin:0 auto;
	max-width: 850px;}
</style>
<div class="article-footer-copyright">
    <!-- <span>本文标题:</span><href="/%20"> Java8新特性之流式数据处理</a><br/> -->
    <!-- <span>文章作者:</span><a href="/" title="访问 Mr.WangLi的个人博客">Mr.WangLi</a><br/> -->
	<span>版权归属:</span><a href="/" title="访问 Mr.WangLi的个人博客">Mr.WangLi</a><br/>
    <span>发布时间:</span>2018年06月20日 - 19:39 | 
    <span>最后更新:</span>2024年09月01日 - 21:23<br/>
    <span>原始链接:</span><a href="/posts/df816e2e.html" title="Java8新特性之流式数据处理">https://blog.biwin.eu.org/posts/df816e2e.html</a><br/>
    <span class="copy-path" title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://blog.biwin.eu.org/posts/df816e2e.html"  aria-label="复制成功！"></i></span><br/>
    <span>许可协议:</span><i class="fab fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">知识共享署名4.0 国际许可协议</a> 转载请保留原文链接及作者。
</div>

    
    <!-- copyright -->
    <div id="post-footer" class="post-footer main-content-wrap">
        
            <div class="post-footer-tags">
                <span class="text-color-light text-small">标签</span><br/>
                
    <a class="tag tag--primary tag--small t-none-link" href="/tags/Java/" rel="tag">Java</a>

            </div>
        
        
            <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/posts/4e2dcaec.html"
                    data-tooltip="Java8新特性之默认接口方法"
                    aria-label="上一篇: Java8新特性之默认接口方法"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/posts/e19f5dc7.html"
                    data-tooltip="Java8新特性之Optional类"
                    aria-label="下一篇: Java8新特性之Optional类"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://blog.biwin.eu.org/posts/df816e2e.html"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.biwin.eu.org/posts/df816e2e.html&amp;title=Java8新特性之流式数据处理"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.biwin.eu.org/posts/df816e2e.html"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


        
        
            
                <br/>
<div class="vcomment"></div>
            
        
    </div>
</article>




                <footer id="footer" class="main-content-wrap">
    <span class="copyrights">
        Copyrights &copy; 2024 Mr.WangLi. All Rights Reserved.
    </span>
    <br/>
    
        <!-- 不蒜子统计 -->
        <span id="busuanzi_container_site_pv">
	                本站总访问量<span id="busuanzi_value_site_pv"></span>次
	        </span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv" style='display:none'>
	                本站访客数<span id="busuanzi_value_site_uv"></span>人
	        </span>
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
</footer>

            </div>
            
                <div id="bottom-bar" class="post-bottom-bar" data-behavior="4">
                    <div class="post-actions-wrap">
    <nav>
        <ul class="post-actions post-action-nav">
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/posts/4e2dcaec.html"
                    data-tooltip="Java8新特性之默认接口方法"
                    aria-label="上一篇: Java8新特性之默认接口方法"
                >
                    
                        <i class="fa fa-angle-left" aria-hidden="true"></i>
                        <span class="hide-xs hide-sm text-small icon-ml">上一篇</span>
                    </a>
            </li>
            <li class="post-action">
                
                    
                <a
                    class="post-action-btn btn btn--default tooltip--top"
                    href="/posts/e19f5dc7.html"
                    data-tooltip="Java8新特性之Optional类"
                    aria-label="下一篇: Java8新特性之Optional类"
                >
                    
                        <span class="hide-xs hide-sm text-small icon-mr">下一篇</span>
                        <i class="fa fa-angle-right" aria-hidden="true"></i>
                    </a>
            </li>
        </ul>
    </nav>
    <ul class="post-actions post-action-share">
        <li class="post-action hide-lg hide-md hide-sm">
            <a
                class="post-action-btn btn btn--default btn-open-shareoptions"
                href="#btn-open-shareoptions"
                aria-label="Diesen Beitrag teilen"
            >
                <i class="fa fa-share-alt" aria-hidden="true"></i>
            </a>
        </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://service.weibo.com/share/share.php?&amp;title=https://blog.biwin.eu.org/posts/df816e2e.html"
                    title="分享到 Weibo"
                    aria-label="分享到 Weibo"
                >
                    <i class="fab fa-weibo" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.biwin.eu.org/posts/df816e2e.html&amp;title=Java8新特性之流式数据处理"
                    title="分享到 QQ"
                    aria-label="分享到 QQ"
                >
                    <i class="fab fa-qq" aria-hidden="true"></i>
                </a>
            </li>
        
            
            
            <li class="post-action hide-xs">
                <a
                    class="post-action-btn btn btn--default"
                    target="new" href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.biwin.eu.org/posts/df816e2e.html"
                    title="分享到 Qzone"
                    aria-label="分享到 Qzone"
                >
                    <i class="fa fa-star" aria-hidden="true"></i>
                </a>
            </li>
        
        
            
        
        <li class="post-action">
            
                <a class="post-action-btn btn btn--default" href="#table-of-contents" aria-label="目录">
            
                <i class="fa fa-list" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>


                </div>
                
    <div id="share-options-bar" class="share-options-bar" data-behavior="4">
        <i id="btn-close-shareoptions" class="fa fa-times"></i>
        <ul class="share-options">
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://service.weibo.com/share/share.php?&amp;title=https://blog.biwin.eu.org/posts/df816e2e.html"
                        aria-label="分享到 Weibo"
                    >
                        <i class="fab fa-weibo" aria-hidden="true"></i><span>分享到 Weibo</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.biwin.eu.org/posts/df816e2e.html&amp;title=Java8新特性之流式数据处理"
                        aria-label="分享到 QQ"
                    >
                        <i class="fab fa-qq" aria-hidden="true"></i><span>分享到 QQ</span>
                    </a>
                </li>
            
                
                
                <li class="share-option">
                    <a
                        class="share-option-btn"
                        target="new"
                        href="http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.biwin.eu.org/posts/df816e2e.html"
                        aria-label="分享到 Qzone"
                    >
                        <i class="fa fa-star" aria-hidden="true"></i><span>分享到 Qzone</span>
                    </a>
                </li>
            
        </ul>
    </div>


            
        </div>
        


    
        
    

<div id="about">
    <div id="about-card">
        <div id="about-btn-close">
            <i class="fa fa-times"></i>
        </div>
        
            <img id="about-card-picture" src="https://img.biwin.eu.org/touxiang.jpeg" alt="作者的图片"/>
        
            <h4 id="about-card-name">Mr.WangLi</h4>
        
            <div id="about-card-bio"><p>喜欢技术，喜欢一个人！</p>
</div>
        
        
            <div id="about-card-job">
                <i class="fa fa-briefcase"></i>
                <br/>
                <p>一个有脾气的 Javaer</p>

            </div>
        
        
            <div id="about-card-location">
                <i class="fa fa-map-marker-alt"></i>
                <br/>
                中国·四川·成都
            </div>
        
    </div>
</div>

        
            <div id="algolia-search-modal" class="modal-container">
    <div class="modal">
        <div class="modal-header">
            <span class="close-button"><i class="fa fa-times"></i></span>
            <a href="https://algolia.com" target="_blank" rel="noopener" class="searchby-algolia text-color-light link-unstyled">
                <span class="searchby-algolia-text text-color-light text-small">by</span>
                <img class="searchby-algolia-logo" src="/assets/images/logo-algolia-nebula-blue-full.svg">
            </a>
            <i class="search-icon fa fa-search"></i>
            <form id="algolia-search-form">
                <input type="text" id="algolia-search-input" name="search"
                    class="form-control input--large search-input" placeholder="Search "
                    />
            </form>
        </div>
        <div class="modal-body">
            <div class="no-result text-color-light text-center">没有找到文章</div>
            <div class="results">
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/e800f027.html"
                            aria-label=": Java8新特性之Lambda表达式"
                        >
                            <img class="media-image" src="https://api.dujin.org/bing/1366.php" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/e800f027.html"
                            aria-label=": Java8新特性之Lambda表达式"
                        >
                            <h3 class="media-heading">Java8新特性之Lambda表达式</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2018年6月19日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>lambda表达式是java8给我们带来的几个重量级新特性之一，借用lambda表达式，可以让我们的java程序设计更加简洁。最近新的项目摒弃了1.6的版本，全面基于java8进行开发，本篇文章是java8新特性的第一篇，将探讨行为参数化、lambda表达式，以及方法引用。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/e19f5dc7.html"
                            aria-label=": Java8新特性之Optional类"
                        >
                            <img class="media-image" src="https://api.dujin.org/bing/1366.php" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/e19f5dc7.html"
                            aria-label=": Java8新特性之Optional类"
                        >
                            <h3 class="media-heading">Java8新特性之Optional类</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2018年6月19日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Optional不是对null关键字的一种替代，而是对于null判定提供了一种更加优雅的实现</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/df816e2e.html"
                            aria-label=": Java8新特性之流式数据处理"
                        >
                            <img class="media-image" src="https://api.dujin.org/bing/1366.php" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/df816e2e.html"
                            aria-label=": Java8新特性之流式数据处理"
                        >
                            <h3 class="media-heading">Java8新特性之流式数据处理</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2018年6月20日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>java8的流式处理极大了简化我们对于集合、数组等结构的操作，让我们可以以函数式的思想去操作，本篇文章将探讨java8的流式数据处理的基本使用。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/4e2dcaec.html"
                            aria-label=": Java8新特性之默认接口方法"
                        >
                            <img class="media-image" src="https://api.dujin.org/bing/1366.php" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/4e2dcaec.html"
                            aria-label=": Java8新特性之默认接口方法"
                        >
                            <h3 class="media-heading">Java8新特性之默认接口方法</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2018年6月21日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>从java8开始，接口不只是一个只能声明方法的地方，我们还可以在声明方法时，给方法一个默认的实现，我们称之为默认接口方法，这样所有实现该接口的子类都可以持有该方法的默认实现。</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/f5f90d4.html"
                            aria-label=": 一、(Docker系列)初识Docker，搭建本地环境"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/f5f90d4.html"
                            aria-label=": 一、(Docker系列)初识Docker，搭建本地环境"
                        >
                            <h3 class="media-heading">一、(Docker系列)初识Docker，搭建本地环境</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年11月5日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>学习搭建Docker环境，结合{ % post_link docker工具箱命令集-问题集锦 % }食用，效果佳</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/1d2e50aa.html"
                            aria-label=": 二、(Docker系列)Docker灵魂探讨"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/1d2e50aa.html"
                            aria-label=": 二、(Docker系列)Docker灵魂探讨"
                        >
                            <h3 class="media-heading">二、(Docker系列)Docker灵魂探讨</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年11月6日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>深入学习Image和Container</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/a2fc68e9.html"
                            aria-label=": 三、(Docker系列)Docker精髓剖析-网络"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/a2fc68e9.html"
                            aria-label=": 三、(Docker系列)Docker精髓剖析-网络"
                        >
                            <h3 class="media-heading">三、(Docker系列)Docker精髓剖析-网络</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年11月15日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Docker和Linux中的网络深入</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/525c4592.html"
                            aria-label=": 五、(Docker系列)Docker深度提升篇笔记"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/525c4592.html"
                            aria-label=": 五、(Docker系列)Docker深度提升篇笔记"
                        >
                            <h3 class="media-heading">五、(Docker系列)Docker深度提升篇笔记</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年11月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Docker Compose与Docker Swarm</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/a95bfc2e.html"
                            aria-label=": docker工具箱命令集-问题集锦"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/a95bfc2e.html"
                            aria-label=": docker工具箱命令集-问题集锦"
                        >
                            <h3 class="media-heading">docker工具箱命令集-问题集锦</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年11月23日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Vagrant Docker 命令集解释备忘</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
                <div class="media">
                    
                    <div class="media-left">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/8d02a8ee.html"
                            aria-label=": 四、(Docker系列)Docker项目实战"
                        >
                            <img class="media-image" src="https://5b868fd.webp.li/docker-conver.png" width="90" height="90"/>
                        </a>
                    </div>
                    
                    <div class="media-body">
                        <a
                            class="link-unstyled"
                            href="https://blog.biwin.eu.org/posts/8d02a8ee.html"
                            aria-label=": 四、(Docker系列)Docker项目实战"
                        >
                            <h3 class="media-heading">四、(Docker系列)Docker项目实战</h3>
                        </a>
                        <span class="media-meta">
                            <span class="media-date text-small">
                                
                                    2019年12月13日
                                
                            </span>
                        </span>
                        <div class="media-content hide-xs font-merryweather"><p>Docker中的Volume</p></div>
                    </div>
                    <div style="clear:both;"></div>
                    <hr>
                </div>
                
            </div>
        </div>
        <div class="modal-footer">
            <p class="results-count text-medium"
                data-message-zero="没有找到文章"
                data-message-one="找到 1 篇文章"
                data-message-other="找到 {n} 篇文章">
                找到 16 篇文章
            </p>
        </div>
    </div>
</div>

        
        
<div id="cover" style="background-image:url('/assets/images/cover.jpg');"></div>
        <!--SCRIPTS-->

<script src="/assets/js/script-2ilv1quqkw94scdhy4pnuktwociarglt6w05ucfykbnexqz9mfxy2dvfhgcl.min.js"></script>

<!--SCRIPTS END-->


    
        
<script src="https://cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js"></script>

        <script>
            new Valine({
                el: '.vcomment',
                notify: false,
                verify: false,
                appId: "6Im09hBEDOiBEU45f3fOc9Hm-gzGzoHsz",
                appKey: "Tc4aa3tRDVWw4GJEcBNfaAuB",
                placeholder: "发现问题，讨论问题，反馈问题，欢迎您的留言和评论！",
                pageSize:'10',
                avatar:'monsterid',
                meta: ['nick', 'mail'],
                lang:''
            })
        </script>
    



    
<script src="/assets/js/moment-with-locales.js"></script>

    
<script src="/assets/js/algoliasearch.js"></script>

    <script>
        var algoliaClient = algoliasearch('I16OUI732Q', 'e1b3e94dd16c5fd972a4f855178f99f8');
        var algoliaIndex = algoliaClient.initIndex('blog');
    </script>


    </body>
</html>
